import 'package:share_plus/share_plus.dart';
import 'package:flutter/services.dart';
import 'package:jaal/models/network_model/scanned_device.dart';
import 'package:jaal/models/network_model/open_port.dart';

class ShareService {
  static final ShareService _instance = ShareService._internal();
  factory ShareService() => _instance;
  ShareService._internal();

  /// Share basic device information
  Future<void> shareDeviceInfo(ScannedDevice device) async {
    try {
      final deviceInfo = _formatDeviceInfo(device);

      if (deviceInfo.isEmpty) {
        throw Exception('Device information is empty');
      }

      await Share.share(
        deviceInfo,
        subject: 'Network Device Information - ${_getDeviceName(device)}',
      );
    } catch (e) {
      // Fallback to clipboard
      try {
        final deviceInfo = _formatDeviceInfo(device);
        await copyToClipboard(deviceInfo);
        throw Exception(
          'Sharing failed, but copied to clipboard instead. Original error: $e',
        );
      } catch (clipboardError) {
        throw Exception(
          'Both sharing and clipboard failed. Share error: $e, Clipboard error: $clipboardError',
        );
      }
    }
  }

  /// Share device information with port scan results
  Future<void> shareDeviceWithPorts(
    ScannedDevice device,
    PortScanResult? scanResult,
  ) async {
    try {
      final deviceInfo = _formatDeviceInfoWithPorts(device, scanResult);

      if (deviceInfo.isEmpty) {
        throw Exception('Device information is empty');
      }

      await Share.share(
        deviceInfo,
        subject: 'Network Security Report - ${_getDeviceName(device)}',
      );
    } catch (e) {
      rethrow; // Re-throw to let the UI handle it
    }
  }

  /// Share complete network scan summary
  Future<void> shareNetworkSummary(
    List<ScannedDevice> devices,
    Map<String, PortScanResult>? portResults,
  ) async {
    try {
      if (devices.isEmpty) {
        throw Exception('No devices to share');
      }

      final summary = _formatNetworkSummary(devices, portResults);

      if (summary.isEmpty) {
        throw Exception('Network summary is empty');
      }

      await Share.share(
        summary,
        subject: 'Network Scan Report - ${devices.length} Devices Found',
      );
    } catch (e) {
      rethrow; // Re-throw to let the UI handle it
    }
  }

  /// Format basic device information (public method)
  String formatDeviceInfo(ScannedDevice device) {
    return _formatDeviceInfo(device);
  }

  Future<void> copyToClipboard(String text) async {
    try {
      await Clipboard.setData(ClipboardData(text: text));
    } catch (e) {
      rethrow;
    }
  }

  String _formatDeviceInfo(ScannedDevice device) {
    final buffer = StringBuffer();

    buffer.writeln('üì± NETWORK DEVICE INFORMATION');
    buffer.writeln('=' * 35);
    buffer.writeln();

    buffer.writeln('üè∑Ô∏è Device Name: ${_getDeviceName(device)}');
    buffer.writeln('üåê IP Address: ${device.ip}');
    buffer.writeln('üìç MAC Address: ${device.mac ?? 'Unknown'}');
    buffer.writeln('üè≠ Manufacturer: ${_getDeviceManufacturer(device)}');
    buffer.writeln('üîó Connection: ${_getConnectionType(device)}');
    buffer.writeln('üìä Status: Online ‚úÖ'); // Assume online since it was scanned

    if (device.isGateway) {
      buffer.writeln('üè† Type: Gateway/Router');
    } else if (device.isSelf) {
      buffer.writeln('üì± Type: This Device');
    }

    buffer.writeln();
    buffer.writeln('üìÖ Scanned: ${DateTime.now().toString().split('.')[0]}');
    buffer.writeln();
    buffer.writeln('Generated by Jaal : Network Scanner üîç');

    return buffer.toString();
  }

  /// Format device information with port scan results
  String _formatDeviceInfoWithPorts(
    ScannedDevice device,
    PortScanResult? scanResult,
  ) {
    final buffer = StringBuffer();

    buffer.writeln('üîí NETWORK SECURITY REPORT');
    buffer.writeln('=' * 35);
    buffer.writeln();

    // Basic device info
    buffer.writeln('üì± DEVICE INFORMATION');
    buffer.writeln('-' * 25);
    buffer.writeln('üè∑Ô∏è Name: ${_getDeviceName(device)}');
    buffer.writeln('üåê IP: ${device.ip}');
    buffer.writeln('üìç MAC: ${device.mac ?? 'Unknown'}');
    buffer.writeln('üè≠ Manufacturer: ${_getDeviceManufacturer(device)}');
    buffer.writeln('üìä Status: Online ‚úÖ'); // Assume online since it was scanned
    buffer.writeln();

    // Port scan results
    if (scanResult != null) {
      buffer.writeln('üîç PORT SCAN RESULTS');
      buffer.writeln('-' * 25);
      buffer.writeln('üìä Total Ports Scanned: ${scanResult.totalPortsScanned}');
      buffer.writeln('üîì Open Ports Found: ${scanResult.openPortsCount}');
      buffer.writeln('‚è±Ô∏è Scan Duration: ${scanResult.scanDuration.inSeconds}s');
      buffer.writeln(
        'üìÖ Scan Time: ${scanResult.scanTime.toString().split('.')[0]}',
      );
      buffer.writeln();

      if (scanResult.openPorts.isNotEmpty) {
        buffer.writeln('üîì OPEN PORTS DETAILS');
        buffer.writeln('-' * 25);

        // Group ports by security level
        final securePorts = scanResult.openPorts
            .where((p) => p.isSecure)
            .toList();
        final unsecurePorts = scanResult.openPorts
            .where((p) => !p.isSecure)
            .toList();

        if (securePorts.isNotEmpty) {
          buffer.writeln('üîí Secure Ports (${securePorts.length}):');
          for (final port in securePorts) {
            buffer.writeln(
              '  ‚úÖ ${port.port} - ${port.service} (${port.description})',
            );
          }
          buffer.writeln();
        }

        if (unsecurePorts.isNotEmpty) {
          buffer.writeln(
            '‚ö†Ô∏è Potentially Risky Ports (${unsecurePorts.length}):',
          );
          for (final port in unsecurePorts) {
            buffer.writeln(
              '  ‚ö†Ô∏è ${port.port} - ${port.service} (${port.description})',
            );
          }
          buffer.writeln();
        }

        // Security recommendations
        buffer.writeln('üí° SECURITY RECOMMENDATIONS');
        buffer.writeln('-' * 25);
        if (unsecurePorts.isNotEmpty) {
          buffer.writeln('‚Ä¢ Review open ports and close unnecessary ones');
          buffer.writeln('‚Ä¢ Ensure proper firewall configuration');
          buffer.writeln('‚Ä¢ Monitor for unauthorized access attempts');
        } else {
          buffer.writeln(
            '‚Ä¢ Good security posture - only secure ports detected',
          );
        }
        buffer.writeln('‚Ä¢ Regular security scans recommended');
        buffer.writeln();
      } else {
        buffer.writeln('üîí No open ports detected - Good security posture!');
        buffer.writeln();
      }
    }

    buffer.writeln('Generated by Jaal : Network Scanner üîç');
    buffer.writeln('Stay secure! üõ°Ô∏è');

    return buffer.toString();
  }

  /// Format network summary for multiple devices
  String _formatNetworkSummary(
    List<ScannedDevice> devices,
    Map<String, PortScanResult>? portResults,
  ) {
    final buffer = StringBuffer();

    buffer.writeln('üåê NETWORK SCAN SUMMARY');
    buffer.writeln('=' * 35);
    buffer.writeln();

    buffer.writeln('üìä NETWORK OVERVIEW');
    buffer.writeln('-' * 25);
    buffer.writeln('üîç Total Devices: ${devices.length}');
    buffer.writeln(
      '‚úÖ Online: ${devices.length}',
    ); // All scanned devices are assumed online
    buffer.writeln('üìÖ Scan Date: ${DateTime.now().toString().split(' ')[0]}');
    buffer.writeln();

    buffer.writeln('üì± DEVICE LIST');
    buffer.writeln('-' * 25);

    for (int i = 0; i < devices.length; i++) {
      final device = devices[i];
      final type = device.isGateway ? 'üè†' : (device.isSelf ? 'üì±' : 'üíª');

      buffer.writeln('${i + 1}. $type ${_getDeviceName(device)}');
      buffer.writeln('   üåê ${device.ip} ‚úÖ');

      // Add port scan info if available
      if (portResults != null && portResults.containsKey(device.ip)) {
        final result = portResults[device.ip]!;
        if (result.openPortsCount > 0) {
          buffer.writeln('   üîì ${result.openPortsCount} open ports');
        } else {
          buffer.writeln('   üîí No open ports');
        }
      }
      buffer.writeln();
    }

    // Security summary
    if (portResults != null && portResults.isNotEmpty) {
      final totalOpenPorts = portResults.values
          .map((r) => r.openPortsCount)
          .fold(0, (a, b) => a + b);

      buffer.writeln('üîí SECURITY SUMMARY');
      buffer.writeln('-' * 25);
      buffer.writeln('üîì Total Open Ports: $totalOpenPorts');

      if (totalOpenPorts > 0) {
        buffer.writeln('‚ö†Ô∏è Review open ports for security');
      } else {
        buffer.writeln('‚úÖ Good network security posture');
      }
      buffer.writeln();
    }

    buffer.writeln('Generated by Jaal : Network Scanner üîç');
    buffer.writeln('Keep your network secure! üõ°Ô∏è');

    return buffer.toString();
  }

  String _getDeviceName(ScannedDevice device) {
    if (device.isGateway) return 'Home Router';
    if (device.isSelf) return 'This Device';
    return device.displayName;
  }

  String _getDeviceManufacturer(ScannedDevice device) {
    if (device.name?.toLowerCase().contains('iphone') == true) return 'Apple';
    if (device.name?.toLowerCase().contains('macbook') == true) return 'Apple';
    if (device.name?.toLowerCase().contains('samsung') == true) {
      return 'Samsung';
    }
    if (device.name?.toLowerCase().contains('tv') == true) return 'Smart TV';
    return 'Unknown';
  }

  String _getConnectionType(ScannedDevice device) {
    if (device.isGateway) return 'LAN (Gateway)';
    return 'Wi-Fi';
  }
}
